1. hashMap put原理
2. 用一个对象当做key，要重写哪些方法，为什么？
3. 线程池：核心参数，线程池优化
4. synchronize和reentrantLock的实现
5. volatile的实现|MESI缓存一致性协议，内存屏障
6. redis 基本数据类型
7. String的底层数据，为什么不用C的string而是自己重写。
8. 分布式锁：加锁过程，value存什么，怎么实现续租。
9. mysql，B+树的索引结构
10. hashset的底层原理
11. ArrayList和LinkList的场景题
12. 场景题：三个线程分别请求，有一个返回结果，就返回 --> CompletionService

13. mysql innodb 和Myisam
14. 数据库实现乐观锁和悲观锁
15. Springmvc和SpringBoot的区别
16. mybits怎么防止sql注入
17. redis的list实现消息队列
18. 算法：合并两个有序链表
19. dubbo怎么找到的服务端方法
20. 设计一个RPC框架
21. 数据量大你们的梳理方式 |分库分表
22. 代码质量怎么保证
23. 泛型有哪些好处 |说下泛型方法
24. java8流式编程
25. rocketmq的原理
26. rocketmq怎么保证消息不丢
27. rocketmq消息回溯
28. mysql的索引，MVCC
29. 场景题：在线文档，怎么实现版本对比
30. redis的数据结构，详解redis的String，他和java的String的对比
31. Springboot启动都做了哪些事
32. 介绍一下dubbo， provider之间怎么通讯
33. ArrayList详解，什么原因导致不是线程安全的；让你实现怎么保证需要改哪些
34. mysql怎么建索引ABC，AC，D
35. 分库分表：分布式主键生成，怎么不停机扩容。
36. jvm对象分配，进入老年代的条件，垃圾回收，三色标记，g1和cms怎么解决错标
37. 设计个秒杀
38. 算法：数组中找到奇数个的数字
39. 怎么做数据幂等
40. ArrayList的默认大小，每次扩容的大小
41. 了解的注册中心有哪些
42. Spring事务什么时候不生效
43. 容器化技术，maven
44. 三次握手，Ddos攻击
45. hashmap操作的时间复杂度，为什么是8变成红黑树
46. dubbo的原理
47. mysql，为什么最左匹配，事务提交过程，间隙锁
48. Spring的循环依赖
49. 垃圾回收，G1怎么做到的可预计的暂停时间，new Object()占多少内存
50. mybits的#和&有啥区别，工作原理。
51. AQS 
52. mysql哪些情况会导致索引失效,sql优化
53. 项目频繁fullGC怎么排查
54. jvm内存结构
55. rocketMQ的怎么实现的tag过滤。事务消息
56. mybits的#和&有啥区别，工作原理。
57. redis集群架构，线程模型
58. 线程的状态，run和start
59. rocketMQ，事务消息，顺序消息，延时消息怎么实现的延时
60. 缓存和数据库一致性的问题。
61. redis 的缓存穿透，缓存雪崩
62. 线程的状态，流转情况
63. mysql的索引，死锁
64. rocketMq的事务消息
65. DDD领域驱动设计
66. redis的pipeline
67. jar的运行原理tomcat和Spring是怎么相互工作的。
68. spring的循环依赖的情况
69. Spring事务方法内部调用
70. 项目中流量、并发数的控制
71. 链路追踪，traceId的生成怎么做，多线程下traceId
72. redis hash的底层数据结构
73. java8的Stream会改变原数据吗
74. dubbo架构，调用的原理